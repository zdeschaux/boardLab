#!/usr/bin/env python
import os, sys, inspect
from cairoStuff import *
from pcb import *
from config import *
import gobject, threading
import time, json
import signal, SocketServer
from collections import deque

noTracking = False
#This enables you to make UI changes without connecting a tracker
if len(sys.argv) >=2 and sys.argv[1] == 'dummy':
    noTracking = True
else:
    import tracking
    from tracking import trackingObj as trackingObject

class TrackingSignaller(gobject.GObject):
    def __init__(self):
        self.__gobject_init__()
       
gobject.type_register(TrackingSignaller)
gobject.signal_new("tracking_frame", TrackingSignaller, gobject.SIGNAL_RUN_FIRST,gobject.TYPE_NONE, (str,))
gobject.signal_new("mouse_frame", TrackingSignaller, gobject.SIGNAL_RUN_FIRST,gobject.TYPE_NONE, (str,))
gobject.signal_new("ui_event", PCB, gobject.SIGNAL_RUN_FIRST,gobject.TYPE_NONE, (str,))
gobject.signal_new("probe_event",ProbeSignaller, gobject.SIGNAL_RUN_FIRST,gobject.TYPE_NONE, (str,))

displayQueue = deque([])

class MyTCPHandler(SocketServer.BaseRequestHandler):
    """
    Output of the PCB stuff
    The RequestHandler class for our server.
    It is instantiated once per connection to the server, and must
    override the handle() method to implement communication to the
    client.
    """

    #This is the real handle, the other one is just to test stuff without a real tracking system.
    def handle(self):
        # self.request is the TCP socket connected to the client
        while(1):
            if len(displayQueue) > 0:
                self.data = displayQueue.popleft()
            else:
                self.data = "null"
            self.data += '\n'
            self.request.sendall(self.data)
            time.sleep(0.100)


            
#Eventually this will be replaced by a event driven system, and the events will be generated by the AutoLoader,PCB, etc stuff
def displayLoop():
    HOST, PORT = "localhost", 9877
    # Create the server, binding to localhost on port 9999
    SocketServer.TCPServer.allow_reuse_address = True
    server = SocketServer.TCPServer((HOST, PORT), MyTCPHandler)
    # Activate the server; this will keep running until you
    # interrupt the program with Ctrl-C
    server.serve_forever()


class AutoLoader(object):
    def __init__(self,gtkWindow,eventPipe):
        self.objects = {}
        self.window = gtkWindow
        self.eventPipe = eventPipe

        fileName = 'funo.brd' 
        print "Loading PCB %s"%(fileName,)
        self.pcb = PCB(fileName,usingMouse=noTracking)
        self.pcb.show( )
        window.add(self.pcb)
        
    def processTrackingFrame(self,b,data):
        a = json.loads(data)
        #print 'received trackingFrame',b,a
        self.pcb.processTrackingFrame(a)

    def processMouseFrame(self,b,data):
        a = json.loads(data)
        self.pcb.processMouseFrame(a)

    def forwardUIEvent(self,b,data):
        print 'uiEvent',data
        #self.eventPipe.write(data)
        displayQueue.append(data)


def trackingLoop(sender):
    #Input of the PCB stuff
    while(1):
        if not noTracking:
            a = trackingObject.getFrame()
            if a is not None:
                sender.emit("tracking_frame",json.dumps(a))


def mousePress(a,b):
    data = {'x':b.x, 'y':b.y, 'button':b.button, 'type':'press'}
    trackingSignaller.emit("mouse_frame",json.dumps(data))


def mouseRelease(a,b):
    data = {'x':b.x, 'y':b.y, 'button':b.button, 'type':'release'}
    trackingSignaller.emit("mouse_frame",json.dumps(data))


if __name__=="__main__":
    print sys.argv
    window = gtk.Window( )
    window.set_events(gdk.BUTTON_PRESS_MASK | gdk.MOTION_NOTIFY | gdk.POINTER_MOTION_MASK| gdk.BUTTON_RELEASE_MASK)

    window.connect( "delete-event", gtk.main_quit )

    if noTracking:
        window.connect('button-press-event',mousePress)
        window.connect('button-release-event',mouseRelease)

    window.set_size_request ( width, height )

    # Open a named pipe
    if False:

wfPath = "./p2"
try:
    os.mkfifo(wfPath)
    os.mkfifo(rfPath)
except OSError:
    pass
rp = open(rfPath, 'r')
response = rp.read()
print "P2 hear %s" % response
rp.close()
wp = open(wfPath, 'w')
wp.write("P2: I'm fine, thank you! And you?")		
wp.close()
rp = open(rfPath, 'r')
response = rp.read()
print "P2 hear %s" % response
rp.close()

        try:
            os.remove(namedPipe)
        except OSError:
            print 'Couldn\'t delete the named pipe, maybe it wasn\'t there...'
        os.mkfifo(namedPipe,0644)
        eventPipe = os.open(namedPipe, os.O_NONBLOCK|os.O_WRONLY)     # open fifo pipe file as fd

    autoLoader = AutoLoader(window,None)

    autoLoader.pcb.connect("ui_event",autoLoader.forwardUIEvent)    
    trackingSignaller = TrackingSignaller()
    trackingSignaller.connect("tracking_frame",autoLoader.processTrackingFrame)
    trackingSignaller.connect("mouse_frame",autoLoader.processMouseFrame)

    trackingThread = threading.Thread(target=trackingLoop,args=(trackingSignaller,))
    trackingThread.start()

    displayThread = threading.Thread(target=displayLoop)
    displayThread.start()

    window.present( )
    gtk.main()

