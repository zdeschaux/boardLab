#!/usr/bin/env python
import os, sys, inspect
from cairoStuff import *
from pcb import *
from config import *
import gobject, threading
import time, json
import signal, SocketServer
from collections import deque
from matplotlib.figure import Figure
from numpy import arange, sin, pi

#from matplotlib.backends.backend_gtkagg import FigureCanvasGTKAgg as FigureCanvas
#from matplotlib.backends.backend_gtk import FigureCanvasGTK as FigureCanvas
from matplotlib.backends.backend_gtkcairo import FigureCanvasGTKCairo as FigureCanvas

if not noTracking:
    import tracking
    from tracking import trackingObj as trackingObject

# Dummy probe or real probe
if not noProbe:
    from probeEvents import probeObj


# Dummy multimeter or real multimeter
if not noMultimeter:
    from multimeter import multimeterObj
else:
    from dummyMultimeter import dummyMultimeterObj as multimeterObj


class TrackingSignaller(gobject.GObject):
    def __init__(self):
        self.__gobject_init__()

       
class ProbeSignaller(gobject.GObject):
    def __init__(self):
        self.__gobject_init__()


gobject.type_register(TrackingSignaller)
gobject.signal_new("tracking_frame", TrackingSignaller, gobject.SIGNAL_RUN_FIRST,gobject.TYPE_NONE, (str,))
gobject.signal_new("mouse_frame", TrackingSignaller, gobject.SIGNAL_RUN_FIRST,gobject.TYPE_NONE, (str,))
gobject.signal_new("ui_event", PCB, gobject.SIGNAL_RUN_FIRST,gobject.TYPE_NONE, (str,))
gobject.signal_new("probe_event",ProbeSignaller, gobject.SIGNAL_RUN_FIRST,gobject.TYPE_NONE, (str,))

displayQueue = deque([])

class MyTCPHandler(SocketServer.BaseRequestHandler):
    """
    Output of the PCB stuff
    The RequestHandler class for our server.
    It is instantiated once per connection to the server, and must
    override the handle() method to implement communication to the
    client.
    """

    #This is the real handle, the other one is just to test stuff without a real tracking system.
    def handle(self):
        # self.request is the TCP socket connected to the client
        while(1):
            if len(displayQueue) > 0:
                self.data = displayQueue.popleft()
            else:
                self.data = "null"
            self.data += '\n'
            self.request.sendall(self.data)
            time.sleep(0.100)


            
#Eventually this will be replaced by a event driven system, and the events will be generated by the AutoLoader,PCB, etc stuff
def displayLoop():
    HOST, PORT = "localhost", 9877
    # Create the server, binding to localhost on port 9999
    SocketServer.TCPServer.allow_reuse_address = True
    server = SocketServer.TCPServer((HOST, PORT), MyTCPHandler)
    # Activate the server; this will keep running until you
    # interrupt the program with Ctrl-C
    server.serve_forever()


class AutoLoader(object):
    def __init__(self,gtkWindow,eventPipe):
        self.objects = {}
        self.window = gtkWindow
        self.eventPipe = eventPipe

        fileName = 'funo.brd' 
        print "Loading PCB %s"%(fileName,)

        self.table = gtk.Table(rows=12, columns=1, homogeneous=True)

        window.add(self.table)
        self.table.show()

        self.pcb = PCB(fileName,usingMouse=noTracking,multimeter=multimeterObj, x=pcb_x, y=pcb_y, modeupdate=self.set_status_mode)
        
        self.table.attach(self.pcb, left_attach = 0, right_attach = 1, top_attach = 0, bottom_attach = 4, xpadding=0, ypadding=0)
        
        self.pcb.show( )

        f = Figure(figsize=(5,4), dpi=100, facecolor='white')
        a = f.add_subplot(211)
        b = f.add_subplot(212)
        t1 = arange(0.0, 3.0, 0.01)
        t2 = arange(0.0, 5.0, 0.01)
        s1 = sin(2*pi*t1)
        s2 = sin(2*pi*t2)
        a.plot(t1, s1)
        a.set_title('Channel 1', fontsize=10)
        a.tick_params(labelsize=8)
        a.grid(True,which='both')
        b.plot(t2, s2)
        b.tick_params(labelsize=8)
        b.grid(True,which='both')
        b.set_title('Channel 2', fontsize=10)
        f.tight_layout()
        
        canvas = FigureCanvas(f)
        self.table.attach(canvas, left_attach = 0, right_attach = 1, top_attach = 4, bottom_attach = 11, xpadding=0, ypadding=0)
        canvas.show()
        
        self.status_bar = gtk.Statusbar() 
        self.table.attach(self.status_bar, left_attach = 0, right_attach = 1, top_attach = 11, bottom_attach = 12, xpadding=0, ypadding=0)

        self.status_bar.show()
        self.cid = self.status_bar.get_context_id('')
        self.status_bar.push(self.cid,'Operation Mode: select')

    def set_status_mode(self,text):
        self.status_bar.pop(self.cid)
        self.cid = self.status_bar.get_context_id('')
        self.status_bar.push(self.cid,'Operation Mode: %s'%(text,))

    def processTrackingFrame(self,b,data):
        a = json.loads(data)
        #print 'received trackingFrame',b,a
        self.pcb.processTrackingFrame(a)

    def processMouseFrame(self,b,data):
        a = json.loads(data)
        self.pcb.processMouseFrame(a)

    def processProbeEvent(self,b,data):
        a = json.loads(data)
        self.pcb.probeEvent(a)

    def forwardUIEvent(self,b,data):
        print 'uiEvent',data
        #self.eventPipe.write(data)
        displayQueue.append(data)


def trackingLoop(sender):
    #Input of the PCB stuff
    while(1):
        if not noTracking:
            a = trackingObject.getFrame()
            if a is not None:
                sender.emit("tracking_frame",json.dumps(a))


def probeLoop(sender):
    while(1):
        if not noProbe:
            a = probeObj.getEvent()
            if a is not None:
                sender.emit("probe_event",json.dumps(a))


def mousePress(a,b):
    data = {'x':b.x, 'y':b.y, 'button':b.button, 'type':'press'}
    trackingSignaller.emit("mouse_frame",json.dumps(data))


def mouseRelease(a,b):
    data = {'x':b.x, 'y':b.y, 'button':b.button, 'type':'release'}
    trackingSignaller.emit("mouse_frame",json.dumps(data))


if __name__=="__main__":
    print sys.argv
    window = gtk.Window( )
    window.set_events(gdk.BUTTON_PRESS_MASK | gdk.MOTION_NOTIFY | gdk.POINTER_MOTION_MASK| gdk.BUTTON_RELEASE_MASK)

    window.connect( "delete-event", gtk.main_quit )

    if noTracking:
        window.connect('button-press-event',mousePress)
        window.connect('button-release-event',mouseRelease)

    window.set_size_request ( pcb_width, pcb_height )

    # Open a named pipe
    if False:
        wfPath = "./p2"
        try:
            os.mkfifo(wfPath)
            os.mkfifo(rfPath)
        except OSError:
            pass
        rp = open(rfPath, 'r')
        response = rp.read()
        print "P2 hear %s" % response
        rp.close()
        wp = open(wfPath, 'w')
        wp.write("P2: I'm fine, thank you! And you?")		
        wp.close()
        rp = open(rfPath, 'r')
        response = rp.read()
        print "P2 hear %s" % response
        rp.close()
        
        try:
            os.remove(namedPipe)
        except OSError:
            print 'Couldn\'t delete the named pipe, maybe it wasn\'t there...'
        os.mkfifo(namedPipe,0644)
        eventPipe = os.open(namedPipe, os.O_NONBLOCK|os.O_WRONLY)     # open fifo pipe file as fd

    autoLoader = AutoLoader(window,None)

    autoLoader.pcb.connect("ui_event",autoLoader.forwardUIEvent)    
    trackingSignaller = TrackingSignaller()
    trackingSignaller.connect("tracking_frame",autoLoader.processTrackingFrame)
    trackingSignaller.connect("mouse_frame",autoLoader.processMouseFrame)
    
    probeSignaller = ProbeSignaller()
    probeSignaller.connect("probe_event",autoLoader.processProbeEvent)

    probeThread = threading.Thread(target=probeLoop,args=(probeSignaller,))
    probeThread.start()

    trackingThread = threading.Thread(target=trackingLoop,args=(trackingSignaller,))
    trackingThread.start()

    displayThread = threading.Thread(target=displayLoop)
    displayThread.start()

    window.present( )
    gtk.main()

