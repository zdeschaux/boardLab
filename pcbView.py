#!/usr/bin/env python
import sys, inspect
from cairoStuff import *
from pcb import *
from config import *
import gobject, threading
import time, json
import signal, SocketServer
from collections import deque


noTracking = False
#This enables you to make UI changes without connecting a tracker
if len(sys.argv) >=2 and sys.argv[1] == 'dummy':
    noTracking = True
else:
    import tracking
    from tracking import trackingObj as trackingObject

class TrackingSignaller(gobject.GObject):
    def __init__(self):
        self.__gobject_init__()
       
gobject.type_register(TrackingSignaller)
gobject.signal_new("tracking_frame", TrackingSignaller, gobject.SIGNAL_RUN_FIRST,gobject.TYPE_NONE, (str,))

displayQueue = deque([])

class MyTCPHandler(SocketServer.BaseRequestHandler):
    """
    Output of the PCB stuff
    The RequestHandler class for our server.
    It is instantiated once per connection to the server, and must
    override the handle() method to implement communication to the
    client.
    """

    #This is the real handle, the other one is just to test stuff without a real tracking system.
    def handle1(self):
        # self.request is the TCP socket connected to the client
        while(1):
            if len(displayQueue) > 0:
                self.data = displayQueue.popleft()
            else:
                self.data = "null"
            # just send back the same data, but upper-cased
            self.data += '\n'
            self.request.sendall(self.data)
            time.sleep(0.100)


    def handle(self):
        while(1):
            data = {}
            data['positive'] = {'partName':'U3','pad':'3'}
            data['negative'] = {'partName':'U3','pad':'21'}
            data['type'] = 'VDC'
            data['value'] = 5.04
            dataStr = json.dumps(data)
            print dataStr
            self.request.sendall(dataStr)
            time.sleep(0.500)


#Eventually this will be replaced by a event driven system, and the events will be generated by the AutoLoader,PCB, etc stuff
def displayLoop():
    HOST, PORT = "localhost", 9877
    # Create the server, binding to localhost on port 9999
    SocketServer.TCPServer.allow_reuse_address = True
    server = SocketServer.TCPServer((HOST, PORT), MyTCPHandler)
    # Activate the server; this will keep running until you
    # interrupt the program with Ctrl-C
    server.serve_forever()


class AutoLoader(object):
    def __init__(self,gtkWindow):
        self.objects = {}
        self.window = gtkWindow

        fileName = 'funo.brd' 
        print "Loading PCB %s"%(fileName,)
        self.pcb = PCB(fileName,displayCallback=self.displayCallback)
        self.pcb.show( )
        window.add(self.pcb)
        
    def processTrackingFrame(self,b,data):
        a = json.loads(data)
        #print 'received trackingFrame',b,a
        self.pcb.processTrackingFrame(a)

    def displayCallback(self,a):
        displayQueue.append(a)


def trackingLoop(sender):
    #Input of the PCB stuff
    while(1):
        a = trackingObject.getFrame()
        if a is not None:
            sender.emit("tracking_frame",json.dumps(a))


if __name__=="__main__":
    print sys.argv
    window = gtk.Window( )
    window.connect( "delete-event", gtk.main_quit )
    window.set_size_request ( width, height )

    autoLoader = AutoLoader(window)
    
    if not noTracking:
        trackingSignaller = TrackingSignaller()
        trackingSignaller.connect("tracking_frame",autoLoader.processTrackingFrame)

        trackingThread = threading.Thread(target=trackingLoop,args=(trackingSignaller,))
        trackingThread.start()

    displayThread = threading.Thread(target=displayLoop)
    displayThread.start()

    window.present( )
    gtk.main()

